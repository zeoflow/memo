package com.zeoflow.memo.processor.entity

import androidx.annotation.NonNull
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.zeoflow.memo.compiler.processing.XFiler
import com.zeoflow.memo.compiler.processing.writeTo
import com.zeoflow.memo.processor.ClassTypes
import com.zeoflow.memo.processor.poet.getDefault
import com.zeoflow.memo.processor.poet.getType

class EntityBuilder(
    var entityData: EntityData,
    var types: ClassTypes
) {

    private fun simpleName(): String {
        return entityData.typeElement.className.simpleName()
    }

    private fun className(): String {
        return simpleName() + "Memo"
    }

    private fun packageName(): String {
        return entityData.typeElement.className.packageName()
    }

    fun generate(filer: XFiler) {
        val fileSpec = FileSpec.builder(
            packageName(),
            className()
        )

        val typeSpec = TypeSpec.classBuilder(className())
            .addModifiers(KModifier.PUBLIC)
            .addKdoc("Code generated by Memo's Compiler. @see [link](https://github.com/zeoflow/memo)\n\n")
            .addKdoc("Code generated based on the [${entityData.entityName}]")

        addInitializer(typeSpec)

        for (field in entityData.fields) {
            addObservable(field, typeSpec)
            addFieldGetterAndSetter(field, typeSpec)
        }

        fileSpec.addType(typeSpec.build())
            .build()
            .writeTo(filer)
    }

    private fun addObservable(field: EntityField, typeSpec: TypeSpec.Builder) {
        if (!field.isObservable) {
            return
        }

        // Add Property
        val mutableLiveData = types.MutableLiveData() as ClassName
        val mutableOfCustom = mutableLiveData.parameterizedBy(field.className)

        val propertySpecMutable = PropertySpec.builder(
            "${field.keyName}Observable",
            mutableOfCustom
        )

        propertySpecMutable.initializer(
            "%T()",
            types.MutableLiveData()
        )

        typeSpec.addProperty(propertySpecMutable.build())

        // Add Observable Binder
        val observer = types.Observer() as ClassName
        val observerOfCustom = observer.parameterizedBy(field.className)

        val funcSpecObservable = FunSpec.builder(
            "${field.keyName}Observable"
        )
        funcSpecObservable
            .addParameter(
                ParameterSpec.builder("owner", types.LifecycleOwner() as ClassName)
                    .addAnnotation(NonNull::class)
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("observer", observerOfCustom)
                    .addAnnotation(NonNull::class)
                    .build()
            )

        funcSpecObservable
            .addCode("${field.keyName}Observable.observe(owner, observer)")

        typeSpec.addFunction(funcSpecObservable.build())

    }

    private fun addFieldGetterAndSetter(field: EntityField, typeSpec: TypeSpec.Builder) {
        val propertySpec = PropertySpec.builder(field.keyName, field.className)
        propertySpec.addAnnotation(NonNull::class)
        if (field.defaultType != null) {
            propertySpec.initializer(
                "%T().value()",
                getType(field.defaultType!!.typeName)
            )
        } else {
            propertySpec.initializer(
                getDefault(field.xFieldElement.type.typeName)
            )
        }

        if (field.functionsType != null) {
            propertySpec
                .mutable()
                .getter(
                    FunSpec.getterBuilder()
                        .addStatement(
                            "return %T().get(%T[%S, field])",
                            getType(field.functionsType!!.typeName),
                            types.Memo(),
                            field.keyName
                        )
                        .build()
                )
            val funcSetter = FunSpec.setterBuilder()
                .addParameter("value", field.className)
                .addStatement(
                    "%T.put(%S, %T().set(value))",
                    types.Memo(),
                    field.keyName,
                    getType(field.functionsType!!.typeName)
                )
            if (field.isObservable) {
                funcSetter.addStatement(
                    "%NObservable.value = value",
                    field.keyName
                )
            }
            propertySpec
                .mutable()
                .setter(funcSetter.build())
        } else {
            propertySpec
                .mutable()
                .getter(
                    FunSpec.getterBuilder()
                        .addStatement(
                            "return %T[%S, field]",
                            types.Memo(),
                            field.keyName
                        )
                        .build()
                )
            val funcSetter = FunSpec.setterBuilder()
                .addParameter("value", field.className)
                .addStatement(
                    "%T.put(%S, value)",
                    types.Memo(),
                    field.keyName
                )
            if (field.isObservable) {
                funcSetter.addStatement(
                    "%NObservable.value = value",
                    field.keyName
                )
            }
            propertySpec
                .mutable()
                .setter(funcSetter.build())
        }

        typeSpec.addProperty(propertySpec.build())
    }

    private fun addInitializer(typeSpec: TypeSpec.Builder) {
        if (entityData.isEncryption) {
            typeSpec.addInitializerBlock(
                CodeBlock.of(
                    "%T.init().withEncryption(%T(%S)).build()",
                    types.Memo(),
                    types.ConcealEncryption(),
                    entityData.encryptionKey
                )
            )
        } else {
            typeSpec.addInitializerBlock(
                CodeBlock.of(
                    "%T.init().withEncryption(%T()).build()",
                    types.Memo(),
                    types.NoEncryption(),
                )
            )
        }
    }
}